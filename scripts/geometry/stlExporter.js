/**
 * STL Exporter
 * Exports Three.js geometries to binary STL format
 */

/**
 * Export geometry to binary STL format
 */
export function exportToBinarySTL(geometry, filename = 'model') {
    // Ensure we have a non-indexed geometry for export
    const exportGeometry = geometry.index ? geometry.toNonIndexed() : geometry.clone();
    exportGeometry.computeVertexNormals();
    
    const positions = exportGeometry.getAttribute('position');
    const normals = exportGeometry.getAttribute('normal');
    
    const triangleCount = positions.count / 3;
    
    // Binary STL format:
    // 80 bytes header
    // 4 bytes triangle count (uint32)
    // For each triangle:
    //   12 bytes normal (3 x float32)
    //   36 bytes vertices (3 x 3 x float32)
    //   2 bytes attribute byte count (uint16)
    
    const bufferLength = 80 + 4 + (triangleCount * 50);
    const buffer = new ArrayBuffer(bufferLength);
    const view = new DataView(buffer);
    
    // Write header (80 bytes)
    const header = `Binary STL - ${filename} - Generated by Dinnerware Generator`;
    for (let i = 0; i < 80; i++) {
        view.setUint8(i, i < header.length ? header.charCodeAt(i) : 0);
    }
    
    // Write triangle count
    view.setUint32(80, triangleCount, true);
    
    // Write triangles
    let offset = 84;
    
    for (let i = 0; i < triangleCount; i++) {
        const i3 = i * 3;
        
        // Calculate face normal (average of vertex normals)
        const nx = (normals.getX(i3) + normals.getX(i3 + 1) + normals.getX(i3 + 2)) / 3;
        const ny = (normals.getY(i3) + normals.getY(i3 + 1) + normals.getY(i3 + 2)) / 3;
        const nz = (normals.getZ(i3) + normals.getZ(i3 + 1) + normals.getZ(i3 + 2)) / 3;
        
        // Normalize
        const len = Math.sqrt(nx * nx + ny * ny + nz * nz);
        
        // Write normal
        view.setFloat32(offset, nx / len, true);
        view.setFloat32(offset + 4, ny / len, true);
        view.setFloat32(offset + 8, nz / len, true);
        offset += 12;
        
        // Write vertices
        for (let j = 0; j < 3; j++) {
            const vi = i3 + j;
            view.setFloat32(offset, positions.getX(vi), true);
            view.setFloat32(offset + 4, positions.getY(vi), true);
            view.setFloat32(offset + 8, positions.getZ(vi), true);
            offset += 12;
        }
        
        // Write attribute byte count (unused, set to 0)
        view.setUint16(offset, 0, true);
        offset += 2;
    }
    
    return buffer;
}

/**
 * Download STL file
 */
export function downloadSTL(buffer, filename) {
    const blob = new Blob([buffer], { type: 'application/octet-stream' });
    const url = URL.createObjectURL(blob);
    
    const link = document.createElement('a');
    link.href = url;
    link.download = filename.endsWith('.stl') ? filename : `${filename}.stl`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    URL.revokeObjectURL(url);
}

/**
 * Export multiple items with progress callback
 */
export async function exportMultipleSTL(items, projectName, progressCallback) {
    const total = items.length;
    
    for (let i = 0; i < items.length; i++) {
        const { type, geometry, displayName } = items[i];
        const filename = `${projectName}_${type}.stl`;
        
        if (progressCallback) {
            progressCallback({
                current: i + 1,
                total,
                itemName: displayName,
                progress: (i + 1) / total
            });
        }
        
        const buffer = exportToBinarySTL(geometry, filename);
        downloadSTL(buffer, filename);
        
        // Small delay between downloads to prevent browser blocking
        if (i < items.length - 1) {
            await new Promise(resolve => setTimeout(resolve, 300));
        }
    }
    
    if (progressCallback) {
        progressCallback({
            current: total,
            total,
            itemName: 'Complete',
            progress: 1,
            complete: true
        });
    }
}

/**
 * Validate geometry for STL export
 */
export function validateGeometry(geometry) {
    const warnings = [];
    
    const positions = geometry.getAttribute('position');
    
    if (!positions || positions.count === 0) {
        warnings.push('Geometry has no vertices');
        return { valid: false, warnings };
    }
    
    if (positions.count % 3 !== 0) {
        warnings.push('Geometry vertex count is not divisible by 3');
    }
    
    // Check for degenerate triangles
    let degenerateCount = 0;
    const triangleCount = geometry.index ? 
        geometry.index.count / 3 : 
        positions.count / 3;
    
    for (let i = 0; i < triangleCount; i++) {
        let i0, i1, i2;
        
        if (geometry.index) {
            i0 = geometry.index.getX(i * 3);
            i1 = geometry.index.getX(i * 3 + 1);
            i2 = geometry.index.getX(i * 3 + 2);
        } else {
            i0 = i * 3;
            i1 = i * 3 + 1;
            i2 = i * 3 + 2;
        }
        
        const v0 = [positions.getX(i0), positions.getY(i0), positions.getZ(i0)];
        const v1 = [positions.getX(i1), positions.getY(i1), positions.getZ(i1)];
        const v2 = [positions.getX(i2), positions.getY(i2), positions.getZ(i2)];
        
        // Check for zero-area triangle
        const e1 = [v1[0] - v0[0], v1[1] - v0[1], v1[2] - v0[2]];
        const e2 = [v2[0] - v0[0], v2[1] - v0[1], v2[2] - v0[2]];
        
        const cross = [
            e1[1] * e2[2] - e1[2] * e2[1],
            e1[2] * e2[0] - e1[0] * e2[2],
            e1[0] * e2[1] - e1[1] * e2[0]
        ];
        
        const area = Math.sqrt(cross[0] * cross[0] + cross[1] * cross[1] + cross[2] * cross[2]) / 2;
        
        if (area < 0.0001) {
            degenerateCount++;
        }
    }
    
    if (degenerateCount > 0) {
        warnings.push(`${degenerateCount} degenerate triangles found`);
    }
    
    return {
        valid: warnings.length === 0,
        warnings,
        triangleCount,
        vertexCount: positions.count
    };
}



